---
# NixOS Tailscale í´ë¼ì´ì–¸íŠ¸ ì„¤ì • í”Œë ˆì´ë¶

- name: Setup Tailscale on NixOS
  hosts: nixos_clients
  become: true
  gather_facts: true
  
  vars:
    tailscale_state_dir: /var/lib/tailscale
    nixos_config_dir: /etc/nixos
    
  tasks:
    - name: Check if NixOS configuration.nix exists
      stat:
        path: "{{ nixos_config_dir }}/configuration.nix"
      register: nixos_config_stat
      
    - name: Fail if not NixOS system
      fail:
        msg: "This playbook is designed for NixOS systems only"
      when: not nixos_config_stat.stat.exists
      
    - name: Read current NixOS configuration
      slurp:
        src: "{{ nixos_config_dir }}/configuration.nix"
      register: current_config
      
    - name: Check if tailscale is already configured
      set_fact:
        tailscale_configured: "{{ 'services.tailscale' in (current_config.content | b64decode) }}"
        
    - name: Backup current NixOS configuration
      copy:
        src: "{{ nixos_config_dir }}/configuration.nix"
        dest: "{{ nixos_config_dir }}/configuration.nix.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      when: not tailscale_configured
      
    - name: Create tailscale configuration snippet
      copy:
        content: |
          # Tailscale VPN Configuration
          services.tailscale = {
            enable = true;
            useRoutingFeatures = "both";  # Enable subnet routing and exit node features
          };
          
          # Open firewall for tailscale
          networking.firewall = {
            checkReversePath = "loose";
            allowedUDPPorts = [ 41641 ]; # Facilitate firewall punching
          };
          
          # Enable IP forwarding for subnet routing
          boot.kernel.sysctl = {
            "net.ipv4.ip_forward" = 1;
            "net.ipv6.conf.all.forwarding" = 1;
          };
        dest: /tmp/tailscale-config.nix
        
    - name: Add tailscale configuration to NixOS config
      blockinfile:
        path: "{{ nixos_config_dir }}/configuration.nix"
        marker: "  # {mark} ANSIBLE MANAGED TAILSCALE CONFIG"
        insertbefore: "^}"
        block: |2
            # Tailscale VPN Configuration
            services.tailscale = {
              enable = true;
              useRoutingFeatures = "both";  # Enable subnet routing and exit node features
            };
            
            # Open firewall for tailscale
            networking.firewall = {
              checkReversePath = "loose";
              allowedUDPPorts = [ 41641 ]; # Facilitate firewall punching
            };
            
            # Enable IP forwarding for subnet routing
            boot.kernel.sysctl = {
              "net.ipv4.ip_forward" = 1;
              "net.ipv6.conf.all.forwarding" = 1;
            };
      when: not tailscale_configured
      
    - name: Rebuild NixOS configuration
      command: nixos-rebuild switch
      when: not tailscale_configured
      register: nixos_rebuild
      failed_when: nixos_rebuild.rc != 0
      
    - name: Wait for tailscale service to be ready
      wait_for:
        path: /run/tailscale/tailscaled.sock
        timeout: 60
      when: not tailscale_configured
      
    - name: Check tailscale status
      command: tailscale status --json
      register: tailscale_status
      failed_when: false
      changed_when: false
      
    - name: Parse tailscale status
      set_fact:
        tailscale_data: "{{ tailscale_status.stdout | from_json }}"
      when: tailscale_status.rc == 0
      
    - name: Check if tailscale is already connected
      set_fact:
        tailscale_connected: "{{ tailscale_data is defined and tailscale_data.BackendState == 'Running' }}"
      when: tailscale_status.rc == 0
      
    - name: Set tailscale as disconnected if status check failed
      set_fact:
        tailscale_connected: false
      when: tailscale_status.rc != 0
      
    - name: Connect to headscale server
      command: >
        tailscale up 
        --login-server={{ headscale_server_url }} 
        --authkey={{ headscale_preauth_key }}
        --accept-routes
        --advertise-routes={{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}
      when: not tailscale_connected and headscale_preauth_key is defined
      register: tailscale_connect
      
    - name: Display connection instructions if no pre-auth key
      debug:
        msg: |
          ğŸ“‹ Tailscale ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!
          
          ìˆ˜ë™ìœ¼ë¡œ ì—°ê²°í•˜ë ¤ë©´ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”:
          sudo tailscale up --login-server={{ headscale_server_url }} --accept-routes --advertise-routes={{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}
          
          ê·¸ ë‹¤ìŒ headscale ì„œë²„ì—ì„œ ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ë…¸ë“œë¥¼ ìŠ¹ì¸í•˜ì„¸ìš”:
          headscale nodes list
          headscale routes list
          headscale routes enable -r <route-id>
      when: not tailscale_connected and headscale_preauth_key is not defined
      
    - name: Get tailscale status after connection
      command: tailscale status
      register: final_tailscale_status
      when: tailscale_connected or (tailscale_connect is defined and tailscale_connect.rc == 0)
      
    - name: Display tailscale network information
      debug:
        msg: |
          ğŸ”— Tailscale ì—°ê²° ì™„ë£Œ!
          
          {{ final_tailscale_status.stdout }}
          
          ë„¤íŠ¸ì›Œí¬ ì •ë³´:
          - ë¡œì»¬ ì„œë¸Œë„·: {{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}
          - Headscale ì„œë²„: {{ headscale_server_url }}
      when: final_tailscale_status is defined
      
    - name: Create tailscale management script
      copy:
        content: |
          #!/usr/bin/env bash
          # Tailscale ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸
          
          set -euo pipefail
          
          HEADSCALE_SERVER="{{ headscale_server_url }}"
          LOCAL_SUBNET="{{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}"
          
          case "${1:-help}" in
            "status")
              tailscale status
              ;;
            "connect")
              if [ -n "${2:-}" ]; then
                tailscale up --login-server="$HEADSCALE_SERVER" --authkey="$2" --accept-routes --advertise-routes="$LOCAL_SUBNET"
              else
                echo "Usage: $0 connect <auth-key>"
                exit 1
              fi
              ;;
            "disconnect")
              tailscale down
              ;;
            "routes")
              tailscale status --json | jq '.Peer[] | select(.Online) | {Name: .HostName, Routes: .PrimaryRoutes}'
              ;;
            "ping")
              if [ -n "${2:-}" ]; then
                tailscale ping "$2"
              else
                echo "Usage: $0 ping <hostname-or-ip>"
                exit 1
              fi
              ;;
            "help"|*)
              echo "Tailscale ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸"
              echo ""
              echo "ì‚¬ìš©ë²•: $0 <command> [options]"
              echo ""
              echo "Commands:"
              echo "  status          - Tailscale ìƒíƒœ í™•ì¸"
              echo "  connect <key>   - Auth keyë¡œ ì—°ê²°"
              echo "  disconnect      - ì—°ê²° í•´ì œ"
              echo "  routes          - ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŠ¸ ì •ë³´"
              echo "  ping <target>   - ë‹¤ë¥¸ ë…¸ë“œ ping í…ŒìŠ¤íŠ¸"
              echo "  help            - ë„ì›€ë§ í‘œì‹œ"
              ;;
          esac
        dest: /usr/local/bin/tailscale-manage
        mode: '0755'
        owner: root
        group: root
        
    - name: Create tailscale monitoring script
      copy:
        content: |
          #!/usr/bin/env bash
          # Tailscale ì—°ê²° ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸
          
          LOG_FILE="/var/log/tailscale-monitor.log"
          HEADSCALE_SERVER="{{ headscale_server_url }}"
          
          log_message() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
          }
          
          check_connection() {
              if tailscale status --json | jq -e '.BackendState == "Running"' > /dev/null 2>&1; then
                  return 0
              else
                  return 1
              fi
          }
          
          check_headscale_reachable() {
              if curl -s --max-time 10 "$HEADSCALE_SERVER/health" > /dev/null 2>&1; then
                  return 0
              else
                  return 1
              fi
          }
          
          if ! check_connection; then
              log_message "WARNING: Tailscale is not running"
              
              if check_headscale_reachable; then
                  log_message "INFO: Headscale server is reachable, attempting to restart tailscale"
                  systemctl restart tailscaled
                  sleep 10
                  
                  if check_connection; then
                      log_message "INFO: Tailscale successfully restarted"
                  else
                      log_message "ERROR: Failed to restart tailscale"
                  fi
              else
                  log_message "ERROR: Headscale server is not reachable"
              fi
          fi
        dest: /usr/local/bin/tailscale-monitor
        mode: '0755'
        owner: root
        group: root
        
    - name: Create systemd timer for tailscale monitoring
      copy:
        content: |
          [Unit]
          Description=Monitor Tailscale Connection
          
          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/tailscale-monitor
          User=root
        dest: /etc/systemd/system/tailscale-monitor.service
        
    - name: Create systemd timer for tailscale monitoring
      copy:
        content: |
          [Unit]
          Description=Run Tailscale Monitor every 5 minutes
          Requires=tailscale-monitor.service
          
          [Timer]
          OnCalendar=*:0/5
          Persistent=true
          
          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/tailscale-monitor.timer
        
    - name: Enable and start tailscale monitoring timer
      systemd:
        daemon_reload: yes
        name: tailscale-monitor.timer
        enabled: yes
        state: started