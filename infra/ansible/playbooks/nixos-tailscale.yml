---
# NixOS Tailscale 클라이언트 설정 플레이북

- name: Setup Tailscale on NixOS
  hosts: nixos_clients
  become: true
  gather_facts: true
  
  vars:
    tailscale_state_dir: /var/lib/tailscale
    nixos_config_dir: /etc/nixos
    
  tasks:
    - name: Check if NixOS configuration.nix exists
      stat:
        path: "{{ nixos_config_dir }}/configuration.nix"
      register: nixos_config_stat
      
    - name: Fail if not NixOS system
      fail:
        msg: "This playbook is designed for NixOS systems only"
      when: not nixos_config_stat.stat.exists
      
    - name: Read current NixOS configuration
      slurp:
        src: "{{ nixos_config_dir }}/configuration.nix"
      register: current_config
      
    - name: Check if tailscale is already configured
      set_fact:
        tailscale_configured: "{{ 'services.tailscale' in (current_config.content | b64decode) }}"
        
    - name: Backup current NixOS configuration
      copy:
        src: "{{ nixos_config_dir }}/configuration.nix"
        dest: "{{ nixos_config_dir }}/configuration.nix.backup.{{ ansible_date_time.epoch }}"
        remote_src: yes
      when: not tailscale_configured
      
    - name: Create tailscale configuration snippet
      copy:
        content: |
          # Tailscale VPN Configuration
          services.tailscale = {
            enable = true;
            useRoutingFeatures = "both";  # Enable subnet routing and exit node features
          };
          
          # Open firewall for tailscale
          networking.firewall = {
            checkReversePath = "loose";
            allowedUDPPorts = [ 41641 ]; # Facilitate firewall punching
          };
          
          # Enable IP forwarding for subnet routing
          boot.kernel.sysctl = {
            "net.ipv4.ip_forward" = 1;
            "net.ipv6.conf.all.forwarding" = 1;
          };
        dest: /tmp/tailscale-config.nix
        
    - name: Add tailscale configuration to NixOS config
      blockinfile:
        path: "{{ nixos_config_dir }}/configuration.nix"
        marker: "  # {mark} ANSIBLE MANAGED TAILSCALE CONFIG"
        insertbefore: "^}"
        block: |2
            # Tailscale VPN Configuration
            services.tailscale = {
              enable = true;
              useRoutingFeatures = "both";  # Enable subnet routing and exit node features
            };
            
            # Open firewall for tailscale
            networking.firewall = {
              checkReversePath = "loose";
              allowedUDPPorts = [ 41641 ]; # Facilitate firewall punching
            };
            
            # Enable IP forwarding for subnet routing
            boot.kernel.sysctl = {
              "net.ipv4.ip_forward" = 1;
              "net.ipv6.conf.all.forwarding" = 1;
            };
      when: not tailscale_configured
      
    - name: Rebuild NixOS configuration
      command: nixos-rebuild switch
      when: not tailscale_configured
      register: nixos_rebuild
      failed_when: nixos_rebuild.rc != 0
      
    - name: Wait for tailscale service to be ready
      wait_for:
        path: /run/tailscale/tailscaled.sock
        timeout: 60
      when: not tailscale_configured
      
    - name: Check tailscale status
      command: tailscale status --json
      register: tailscale_status
      failed_when: false
      changed_when: false
      
    - name: Parse tailscale status
      set_fact:
        tailscale_data: "{{ tailscale_status.stdout | from_json }}"
      when: tailscale_status.rc == 0
      
    - name: Check if tailscale is already connected
      set_fact:
        tailscale_connected: "{{ tailscale_data is defined and tailscale_data.BackendState == 'Running' }}"
      when: tailscale_status.rc == 0
      
    - name: Set tailscale as disconnected if status check failed
      set_fact:
        tailscale_connected: false
      when: tailscale_status.rc != 0
      
    - name: Connect to headscale server
      command: >
        tailscale up 
        --login-server={{ headscale_server_url }} 
        --authkey={{ headscale_preauth_key }}
        --accept-routes
        --advertise-routes={{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}
      when: not tailscale_connected and headscale_preauth_key is defined
      register: tailscale_connect
      
    - name: Display connection instructions if no pre-auth key
      debug:
        msg: |
          📋 Tailscale 설정이 완료되었습니다!
          
          수동으로 연결하려면 다음 명령어를 실행하세요:
          sudo tailscale up --login-server={{ headscale_server_url }} --accept-routes --advertise-routes={{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}
          
          그 다음 headscale 서버에서 다음 명령어로 노드를 승인하세요:
          headscale nodes list
          headscale routes list
          headscale routes enable -r <route-id>
      when: not tailscale_connected and headscale_preauth_key is not defined
      
    - name: Get tailscale status after connection
      command: tailscale status
      register: final_tailscale_status
      when: tailscale_connected or (tailscale_connect is defined and tailscale_connect.rc == 0)
      
    - name: Display tailscale network information
      debug:
        msg: |
          🔗 Tailscale 연결 완료!
          
          {{ final_tailscale_status.stdout }}
          
          네트워크 정보:
          - 로컬 서브넷: {{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}
          - Headscale 서버: {{ headscale_server_url }}
      when: final_tailscale_status is defined
      
    - name: Create tailscale management script
      copy:
        content: |
          #!/usr/bin/env bash
          # Tailscale 관리 스크립트
          
          set -euo pipefail
          
          HEADSCALE_SERVER="{{ headscale_server_url }}"
          LOCAL_SUBNET="{{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask | ipaddr('prefix') }}"
          
          case "${1:-help}" in
            "status")
              tailscale status
              ;;
            "connect")
              if [ -n "${2:-}" ]; then
                tailscale up --login-server="$HEADSCALE_SERVER" --authkey="$2" --accept-routes --advertise-routes="$LOCAL_SUBNET"
              else
                echo "Usage: $0 connect <auth-key>"
                exit 1
              fi
              ;;
            "disconnect")
              tailscale down
              ;;
            "routes")
              tailscale status --json | jq '.Peer[] | select(.Online) | {Name: .HostName, Routes: .PrimaryRoutes}'
              ;;
            "ping")
              if [ -n "${2:-}" ]; then
                tailscale ping "$2"
              else
                echo "Usage: $0 ping <hostname-or-ip>"
                exit 1
              fi
              ;;
            "help"|*)
              echo "Tailscale 관리 스크립트"
              echo ""
              echo "사용법: $0 <command> [options]"
              echo ""
              echo "Commands:"
              echo "  status          - Tailscale 상태 확인"
              echo "  connect <key>   - Auth key로 연결"
              echo "  disconnect      - 연결 해제"
              echo "  routes          - 네트워크 라우트 정보"
              echo "  ping <target>   - 다른 노드 ping 테스트"
              echo "  help            - 도움말 표시"
              ;;
          esac
        dest: /usr/local/bin/tailscale-manage
        mode: '0755'
        owner: root
        group: root
        
    - name: Create tailscale monitoring script
      copy:
        content: |
          #!/usr/bin/env bash
          # Tailscale 연결 모니터링 스크립트
          
          LOG_FILE="/var/log/tailscale-monitor.log"
          HEADSCALE_SERVER="{{ headscale_server_url }}"
          
          log_message() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
          }
          
          check_connection() {
              if tailscale status --json | jq -e '.BackendState == "Running"' > /dev/null 2>&1; then
                  return 0
              else
                  return 1
              fi
          }
          
          check_headscale_reachable() {
              if curl -s --max-time 10 "$HEADSCALE_SERVER/health" > /dev/null 2>&1; then
                  return 0
              else
                  return 1
              fi
          }
          
          if ! check_connection; then
              log_message "WARNING: Tailscale is not running"
              
              if check_headscale_reachable; then
                  log_message "INFO: Headscale server is reachable, attempting to restart tailscale"
                  systemctl restart tailscaled
                  sleep 10
                  
                  if check_connection; then
                      log_message "INFO: Tailscale successfully restarted"
                  else
                      log_message "ERROR: Failed to restart tailscale"
                  fi
              else
                  log_message "ERROR: Headscale server is not reachable"
              fi
          fi
        dest: /usr/local/bin/tailscale-monitor
        mode: '0755'
        owner: root
        group: root
        
    - name: Create systemd timer for tailscale monitoring
      copy:
        content: |
          [Unit]
          Description=Monitor Tailscale Connection
          
          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/tailscale-monitor
          User=root
        dest: /etc/systemd/system/tailscale-monitor.service
        
    - name: Create systemd timer for tailscale monitoring
      copy:
        content: |
          [Unit]
          Description=Run Tailscale Monitor every 5 minutes
          Requires=tailscale-monitor.service
          
          [Timer]
          OnCalendar=*:0/5
          Persistent=true
          
          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/tailscale-monitor.timer
        
    - name: Enable and start tailscale monitoring timer
      systemd:
        daemon_reload: yes
        name: tailscale-monitor.timer
        enabled: yes
        state: started